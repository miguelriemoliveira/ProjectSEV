<?xml version="1.0"?>
<!--This launches all the rustbot system-->
<launch>
  <!--arguments-->
  <arg name="do_stereo" default="true"/>
  <arg name="do_fusion" default="false"/>
  <arg name="do_slam" default="true"/>
  <arg name="do_gps" default="false"/>
  <arg name="do_accumulation" default="true"/>
  <arg name="do_zmq_publish" default="false"/>
  <arg name="do_gimbal_motors" default="false"/>
  <arg name="do_auto_track" default="false"/>
  <arg name="do_supercooljoy_gimbal" default="false"/>
  <arg name="mac_address_termica" default="00:11:1c:01:7c:80"/>
  <arg name="termica_url" default="file:///home/mrs/mrs_ws/src/RUST/RustBot/rustbot_calibration/calibration/termica.yaml"/>

  <!--This is for running the system computing the stereo (and the slam) from played back offline data-->
  <arg name="online_stereo" default="false"/>
  <!--To launch a gui for tunning the stereo parameters-->
  <arg name="config_stereo" default="false"/>
  <!--The desired frames per second-->
  <arg name="fps" default="20"/>
  <!--Queue size for the stereo images. More queue size better the possibilities to sync, but more memory required-->
  <arg name="queue_size" default="500"/>
  <!--data fusion-->
  <group if="$(arg do_fusion)">
    <include file="$(find rustbot_bringup)/launch/EKF_fusion.launch">
        </include>
  </group>
  <!--Stereo nodes -->
  <group ns="stereo">
    <!--Camera drivers (should work only in online mode)-->
    <group if="$(arg online_stereo)">
      <include file="$(find rustbot_bringup)/launch/left_camera.launch">
        <arg name="fps" value="$(arg fps)"/>
      </include>
      <include file="$(find rustbot_bringup)/launch/right_camera.launch">
        <arg name="fps" value="$(arg fps)"/>
      </include>

    </group>
    <!--Stereo processing-->
    <group if="$(arg do_stereo)">
      <node name="stereo_image_proc" pkg="stereo_image_proc" type="stereo_image_proc" output="screen">
<!--        <remap from="/stereo/left/image_raw" to="/stereo/left/image_raw1"/>-->
<!--        <remap from="/stereo/right/image_raw" to="/stereo/right/image_raw1"/>-->
<!--        <remap from="/stereo/left/camera_info" to="/stereo/left/camera_info1"/>-->
<!--        <remap from="/stereo/right/camera_info" to="/stereo/right/camera_info1"/>-->
        <param name="approximate_sync" value="true"/>
        <param name="queue_size" value="$(arg queue_size)"/>
	<!--Melhorar visao stereo -->
        <param name="prefilter_size" value="77"/>
        <param name="prefilter_cap" value="34"/>
        <param name="disparity_range" value="50"/>
        <param name="min_disparity" value="0"/>
        <param name="correlation_window_size" value="35"/>
        <param name="speckle_size" value="1000"/>
        <param name="speckle_range" value="3"/>
        <param name="fullDP" value="true"/>
        <param name="uniqueness_ratio" value="5.0"/>
        <param name="texture_threshold" value="1000"/>
      </node>
      <!--Leitura da termica sincronizada com outros para atribuir temperatura-->
      <node name="escala_termica" pkg="termica_reconstrucao" type="imTermicaScaled.py" output="screen">
      </node>
      <group if="$(arg online_stereo)">
      <!--   Aqui liga a termica sobre a nuvem instantanea para ver de modo online pelo GUI  -->
         <node name="termica_instantanea" pkg="termica_reconstrucao" type="projeta_termica" output="screen">
              <param name="termica_calibration_yaml" value="file://$(find rustbot_calibration)/calibration/termica"/> <!-- Diretorio que contem o arquivo .yaml da calibracao da camera termica -->
              <param name="input_cloud" value="/dados_sync/point_cloud"/>
              <param name="input_image" value="/dados_sync/image_8bits"/>
              <param name="input_odom"  value="/dados_sync/odometry"/>
         </node>
      </group>
      <group unless="$(arg online_stereo)">
      <!--   Aqui liga a termica sobre a nuvem de overlap, linkado com a acumulacao-->
         <node name="termica_instantanea" pkg="termica_reconstrucao" type="projeta_termica" output="screen">
              <param name="termica_calibration_yaml" value="file://$(find rustbot_calibration)/calibration/termica"/> <!-- Diretorio que contem o arquivo .yaml da calibracao da camera termica -->
              <param name="input_cloud" value="/overlap/termica_cloud"/>
              <param name="input_image" value="/overlap/termica_image"        />
              <param name="input_odom"  value="/overlap/termica_odometry"     />
         </node>
      </group>
    </group>
  </group>
  <!--Configure stereo-->
  <group if="$(arg config_stereo)">
    <node name="rqt_reconfigure" pkg="rqt_reconfigure" type="rqt_reconfigure" output="screen">
        </node>
  </group>
  <!--SLAM launch files (several options to do slam. Andry's rtab, Miguel's rtab and Miguel's viso2)-->
  <group if="$(arg do_slam)">

        <group if="$(arg do_fusion)">
	    <include file="$(find rustbot_bringup)/launch/viso2.launch">
		</include>
        </group>
	<group unless="$(arg do_fusion)">
	    <include file="$(find rustbot_bringup)/launch/viso2_withtf.launch">
		</include>
        </group>
  </group>
  <!--Point cloud accumulator-->
  <group if="$(arg do_accumulation)">
  <!-- Acumula visual como ja feito com a nuvem de overlap -->
  <include file="$(find rustbot_bringup)/launch/accumulate.launch">
  </include>
  <!-- Nos de overlap sobre a imagem termica e visual, cada uma repassando imagem nuvem e odometria nos topicos certos para acumular -->
    <node name="overlap_visual" pkg="projecao_overlap" type="projecao_overlap_node" output="screen">
        <param name="camera_calibration_yaml" value="file://$(find rustbot_calibration)/calibration/calibration_50-0536881130"/>
        <param name="cloud_topic_in"  value="/stereo/points2" />
        <param name="cloud_topic_out" value="/overlap/visual_cloud"/>
        <param name="image_topic_in"  value="/stereo/left/image_rect_color" />
        <param name="image_topic_out" value="/overlap/visual_image"/>
        <param name="odom_topic_in"   value="/stereo_odometer/odometry"  />
        <param name="odom_topic_out"  value="/overlap/visual_odometry" />
        <param name="camera_type"     value="left_camera"    />
        <param name="overlap_rate"    value="80"   /> <!--Importante overlap mais baixo-->
    </node>
    <node name="overlap_termica" pkg="projecao_overlap" type="projecao_overlap_node" output="screen">
        <param name="camera_calibration_yaml" value="file://$(find rustbot_calibration)/calibration/calibration_50-0536881130"/>
        <param name="cloud_topic_in"  value="/dados_sync/point_cloud" />
        <param name="cloud_topic_out" value="/overlap/termica_cloud"/>
        <param name="image_topic_in"  value="/dados_sync/image_8bits" />
        <param name="image_topic_out" value="/overlap/termica_image"/>
        <param name="odom_topic_in"   value="/dados_sync/odometry"  />
        <param name="odom_topic_out"  value="/overlap/termica_odometry" />
        <param name="camera_type"     value="termica"    />
        <param name="overlap_rate"    value="95"   /> <!--Importante overlap mais alto pela termica estar focada no centro-->
    </node>

    <!-- Acumula termica com a nuvem vinda do pipeline overlap - reprojecao offline - acumulacao -->
    <node name="acumula_termica" pkg="termica_reconstrucao" type="acumula_termica" output="screen">
    </node>
  </group>

  <!-- UFJF SECTION -->

<!-- TERMICA -->
<group ns="termica">
  <group if="$(arg online_stereo)">
      <include file="$(find rustbot_bringup)/launch/termica.launch">
        <arg name="mac_address" value="$(arg mac_address_termica)"/>
        <arg name="calib_url"   value="$(arg termica_url)"/>
      </include>
</group>
</group>

<!--start the gimbal-->
  <group if="$(arg do_gimbal_motors)">
    <include file="$(find dynamixel_workbench_controllers)/launch/multi_port.launch">
    </include>
  </group>

<!--  here start at any cost the automatic tracking node, if necessary-->
<!--the gps.launch could do the trick, but if it is not lanched yet we come with a new mavros node-->
  <group unless="$(arg do_gps)">
    <group unless="$(arg online_stereo)">
      <group if="$(arg do_auto_track)">
        <include file="$(find mavros)/launch/px4.launch"> <!--so we dont launch again the same driver-->
        </include>
        <node name="controle_automatico" pkg="automatico_mrs" type="controle_automatico" output="screen">
        </node>
      </group>
    </group>
  </group>

<!--if it is not automatic, use the joystick to control gimbal if thats the case -->
  <!--parameters for likely Joy-->
  <arg name="nome_stick" default="Logitech Logitech Attack 3"/>
  <arg name="porta" default="/dev/input/js0"/>
  <group unless="$(arg do_auto_track)">
    <group if="$(arg do_supercooljoy_gimbal)">
      <node name="joy_supercool" pkg="joy" type="joy_node" output="screen">
      </node>
    </group>
  </group>


</launch>
